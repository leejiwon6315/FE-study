# Week8
> 트리

## [ 온라인 강의 내용 ]
### 트리
+ 계층적 구조를 나타내는 자료구조
+ 부모/자식 관계가 존재하는 노드들로 구성됨

#### 트리의 용어
+ 노드(node) : 트리의 구성요소 
+ 루트(root) : 부모가 없는 노드
+ 서브트리(subtree) : 하나의 노드와 자손들로 이루어짐
+ 단말노드(terminal) : 자식이 없는 노드
+ 비단말노드 : 자식을 가지는 노드
+ 자식, 부모, 형제, 조상, 자손 노드 : 인간과 동일 
+ 레벨(level) : 트리의 각층의 번호
+ 높이(height) : 트리의 최대 레벨
+ 차수(degree) : 노드의 자식 노드수 

#### 일반 트리
일반적인 트리는 표현과 구현이 복잡하여 이진 트리를 사용, 이진 트리로 일반적인 트리를 표현할 수 있음

<br/>

### 이진 트리(Binary Tree)
모든 노드가 2개의 서브 트리를 가지고 있는 트리
+ 각 노드에는 최대 2개까지의 자식 노드가 존재
+ 모든 노드의 차수가 2 이하가 됨 -> 구현하기가 수월
+ 서브 트리간의 순서가 존재 (왼쪽, 오른쪽)

#### 일반 트리 -> 이진 트리 변환
![image](https://user-images.githubusercontent.com/60544994/98666288-25b7d700-2390-11eb-9d69-db034d80a229.png)

트리는 형제 노드에서 가장 왼쪽이 우선순위를 갖고 있기 때문에, <br/>
이진트리 변환시 형제 노드의 오른쪽에 위치한 노드를 왼쪽 노드의 하위 노드로 표현 할 수 있음

#### 이진 트리의 성질
+ 노드의 개수가 n개 : 간선의 개수는 n-1
+ 높이가 h : 최소 h개 ~ 최대 2^h-1 개의 노드
+ n개 노드의 이진트리 높이: log(𝑛+1) ~ n

#### 이진 트리의 분류
+ 포화 이진 트리(full binary tree)
  - 트리의 각 레벨에 노드가 모두 존재하는 트리
  
+ 완전 이진 트리(complete binary tree)
  - 높이가 h일 때  레벨 1부터 h-1까지는 노드가 모두 존재
  - 마지막 레벨 h에서는 노드가 순서대로 채워짐
  
+ 기타 이진 트리

#### 이진 트리의 추상 자료형
데이터
+ 노드와 간선의 집합
+ 노드는 공집합 혹은 루트 노드, 왼쪽 서브트리, 오른쪽 서브트리로 구성
<br/>

연산
+ `create()`: 이진트리를 생성한다.
+ `isEmpty()`: 이진트리가 공백 상태인지 확인한다.
+ `getRoot()`: 이진트리의 루트 노드를 반환한다.
+ `getCount()`: 이진트리의 노드의 수를 반환한다.
+ `getHeight()`: 이진트리의 높이를 반환한다.
+ `insertNode(n)`: 이진트리에 노드 n을 삽입한다.
+ `deleteNode(n)`: 이진트리에서 노드 n을 삭제한다.
+ `display()`: 이진트리의 내용을 화면에 출력한다.

#### 이진 트리의 표현
+ 배열 : 모든 이진 트리를 포화 이진 트리로 가정
+ 링크 : 부모 노드가 자식 노드를 가리키게 

#### 이진 트리의 순회
+ 전위순회(preorder traversal)<br/>
  루트 -> 왼쪽 자식 -> 오른쪽 자식 
  ```
  void preOrder(TNode *n){
    if (n != NULL){
      printf("[%c] ", n->data); 
      preOrder(n->left);
      preOrder(n->right); 
    }
  }
  ```
  
+ 중위순회(inorder traversal)<br/>
  왼쪽 자식 -> 루트 -> 오른쪽 자식
  ```
  void inOrder(TNode *n){ 
    if( n != NULL ){
    	inOrder(n->left);
    	printf("[%c] ", n->data);
    	inOrder(n->right);
    }
  }

  ```
  
+ 후위순회(postorder traversal)<br/>
  왼쪽 자식 -> 오른쪽 자식 -> 루트
  ```
  void postOrder(TNode *n){
    if (n != NULL){
      postOrder(n->left);
      postOrder(n->right); 
      printf("[%c] ", n->data); 
    }
  }
  ```

#### 레벨 순회
노드를 레벨 순으로 검사
```
level_order(){
  queue<int> q;
  q.push(root);

  while(!q.empty()){
    x = q.front;
    q.pop();
    q.push(left(x));
    q.push(righjt(x));
  }
}
```

<br/>
<br/>

## [ 화상 강의 토론 ]
트리에 대해 조장이 수업 내용을 정리해주고, 팀원 다 같이 도전문제와 퀴즈를 풀었다.<br/>
ppt에 내용을 이해 못하여 조장에게 질문을 하였는데, 다른 팀원이 잘 대답해 주었다.

<br/>
<br/>

## [ 8주차 수업 소감 ]
트리에 대한 기본 개념은 쉽다고 생각했다. 하지만 아직 노드와 클래스를 다루는 것에 익숙치 않은 것 같다.<br/>
개념은 모두 이해하였으나, 코드를 보고 바로는 이해하기 힘들었다.<br/>
이전까지 쓰는 노드를 사용하는 것이 아니라, 트리를 위한 노드를 새로 생성하여 노드에서 하위 자식 노드들 두개에 모두 접근 가능하게 구현을 해야했다.<br/>
조금 더 노드와 클래스의 응용에 대해 공부해야겠다.
