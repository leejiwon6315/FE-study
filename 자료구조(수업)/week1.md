# Week1
> 자료구조와 알고리즘

## [ 온라인 강의 내용 ]

### 일상 생활에서 자료를 정리하고 조직화하는 이유
+ 사물을 편리하고 효율적으로 사용하기 위함<br/>
+ 다양한 자료를 효율적인 규칙에 따라 정리한 예<br/>
  (회사 조직도, 네트워크 은행항구 등)
  
<br/>

### 자료구조(Data Structure)
컴퓨터에서 자료를 정리하고 조직화하는 다양한 구조

<br/>

### 컴퓨터 프로그램의 구성
```프로그램 = 자료구조 + 알고리즘```<br/>
(최대값 탐색 프로그램 = 배열 + 순차탐색)

<br/>

### 알고리즘
컴퓨터로 문제를 풀기 위한 단계적인 절차

#### 알고리즘의 조건
+ 입력 : 0개 이상의 입력
+ 출력 : 1개 이상의 출력
+ 명백성 : 의미가 명확해야 함
+ 유한성 : 반드시 종료되어야 함
+ 유효성 : 실행가능한 유효한 연산이어야함

#### 알고리즘의 기술 방법
+ 자연어 : 우리가 사용하는 언어
  - 인간이 읽기 쉬움
  - 단어들을 정확히 정의하지 않으면 의미전달이 모호해 질 수 있음
+ 흐름도 : flow chart
  - 직관적이고 이해하기 쉬운 알고리즘 기술 방법
  - 복잡한 알고리즘의 경우 이해하기 힘들어짐
+ 유사코드 : pseudo - code
  - 알고리즘의 고수준 기술 방법
  - 자연어보다 구조적인 표현
  - 알고리즘 기술에 가장 많이 사용
  - 실제 구현할 때의 제한 및 버그를 감출 수 있음
  - 알고리즘의 핵심 내용에만 집중이 가능
  ```
  ArrayMax(A,n)
    tmp <- A[0];
    for i<-1 to n-1 do
      if tmp < A[i],
      then tmp <- A[i];
    return tmp;
   
    // 유사코드는 특정 방법으로 정형화되어 있지는 않음
  ```    
+ 특정 프로그래밍 언어
  - 알고리즘의 가장 정확한 기술
  - 실제 구현 시, 많은 구체적인 사항들이 알고리즘의 핵심 내용의 이해를 방해할 수 있음
  ```
  #define MAX 100
  int score[MAX];
  
  int findMaxScore(int n){
    int tmp = score[0];
    for(int i=0; i<n; i++){
      if(score[i] > tmp) tmp = score[i];
    }
    return tmp;
  }
  ``` 
<br/>

### 자료형과 추상 자료형
#### 추상화
+ 어떤 시스템의 간략화 된 기술 또는 명세
+ 시스템의 핵심적인 구조나 동작에만 집중

#### 자료형(data type)
+ 데이터의 집합과 연산의 집합

#### 추상 자료형(ADT:Abstract Data Type)
> 면밀한 정의는 아님
+ 데이터 타입을 추상적(수학적)으로 정의한 것
+ 데이터나 연산이 무엇인가 정의
+ 데이터나 연산을 어떻게 구현할 것인지 정의하지 않음

#### 추상 자료형과 C++
+ 추상 자료형과 C++의 객체지향의 개념은 정확히 일치함<br/>
  (class를 사용하여 구현 가능)
+ 추상 자료형의 `객체`는 class의 `속성(멤버 변수)`로 구현되고 `연산`은 class의 `메소드(멤버 함수)`로 구현
+ C++에서는 `private`나 `protected` 키워드를 이용하여 속성과 연산에 대한 접근을 제한 할 수 있다.
+ class는 계층구조(상속)로 구성될 수 있음
<br/>

### 알고리즘의 성능분석
#### 실행시간 측정하는 법
+ 두 개의 알고리즘의 실제 실행 시간을 측정하는 것
+ 실제로 구현하는 것이 필요
+ 동일한 하드웨어를 사용

#### 알고리즘 복잡도 분석법
+ 직접 구현하지 않고 수행시간 분석
+ 알고리즘이 수행하는 연산의 횟수를 측정하여 비교
+ 일반적으로 연산의 횟수는 n의 함수
+ 시간 복잡도 분석 : 수행 시간 분석
+ 공간 복잡도 분석 : 메모리 공간 분석

#### 실행시간 측정
`clock()` 함수 호출
+ 호출되었을 때의 시스템 시각 반환
+ CLOCKS_PER_SEC 단위
  ```
  clock_t start, finish;
  double duration;
  start = clock();

  // code..

  finish = clock();
  duration = (double)(finish = start)/CLOCKS_PER_SEC;
  return duration;
  ```

#### 복잡도 분석
시간복잡도
+ 기본적인 연산 고려
+ 알고리즘 수행시 연산의 개수를 계산
+ 입력의 개수 n에 대한 함수 -> 시간복잡도 함수, T(n)

#### 빅오 표기법
> 두 개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n >= n0에 대하여,<br/>
> |f(n)| <= C|g(n)| (C는 상수)를 만족하는 C와 n0가 존재하면 `f(n) = O(g(n))`이다.
+ 연산의 횟수를 대략적으로 표기
+ 함수의 상한을 표시
+ 차수가 가장 큰 항이 가장 영향을 크게 미치고, 다른 항들은 상대적으로 무시될 수 있음

#### 빅오메가 표기법
> 빅오 표기법과 반대개념, 빅오의 정의에서 주어지는 부등호가 반대방향이다
+ 함수의 하한을 표시

#### 빅세타 표기법
> 모든 n>=n0에 대하여 C1|g(n)| <= f(n)| <= C2|g(n)| (C1, C2는 상수)를 만족하는<br/>
C1, C2와 n0가 존재하면 `f(n) = θ(g(n))`이다.
+ 함수의 하한인 동시에 상한을 표시
+ 빅오와 빅오메가가 같다면 빅세타도 같다

#### 최선, 평균, 최악의 경우
+ 최선의 경우(best case) : 의미가 없는 경우가 많음
+ 평균의 경우(average case) : 계산하기 어려움
+ 최악의 경우(worst case) : 가장 의미있는 경우

<br/>
## [ 화상 강의 토론 ]
오리엔테이션 진행<br/> 
팀 구성
